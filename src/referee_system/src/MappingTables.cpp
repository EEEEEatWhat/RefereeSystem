/**
 * @author suzukisuncy
 * @date 2023/11/27
 * @brief 通过映射表来解析数据,映射表接受cmd_id，对应DJI裁判系统附录,基于DJI裁判系统协议V1.6
*/

#include <memory>
#include <functional>
#include <boost/asio.hpp>
#include"MappingTables.h"

namespace RM_referee{
    TypeMethodsTables::TypeMethodsTables(){}
    TypeMethodsTables::~TypeMethodsTables() {}
    /**
     * @brief 通过map键值对解包
     * @brief 查表效率可能没有switch高，后续看情况选择
     * @param cmd_id 键
     * @param data 待解包数据
     * @param buf 解包后存放位置
     * @warning 注意内存大小不要越界访问
    */
    void TypeMethodsTables::MapSolve(const uint16_t cmd_id , uint8_t* data ,uint8_t* buf){
        auto it = m_map.find(cmd_id);
        if(it!=m_map.end())
            it->second->SolvePacket(data ,buf );
        else
        {
            printf("\ncurrent cmd_id does not exist! error id : 0x%x\n",cmd_id);
            // throw std::out_of_range("cmd_id not found in map");
        }
    }

    void TypeMethodsTables::SerialReadAsync(boost::asio::serial_port& serialPort,std::vector<uint8_t>& buffer) {
        boost::asio::async_read(serialPort, boost::asio::buffer(buffer), boost::asio::transfer_exactly(sizeof(RM_referee::PacketHeader)),
            [&, header = RM_referee::PacketHeader()](const boost::system::error_code& ec, std::size_t bytes_transferred) mutable {
                if (!ec) {
                    /** 
                     * TODO:
                     * 数据处理逻辑
                     * 0.第一字节默认0xA5
                     * 1.接受长度小于头长度，退出，等待下次 ？
                     * 2.直接memcpy（大小端?）  
                     * 3.CRC校验
                     *  清除处理过的头数据包，开始数据端处理
                     * 0.检查buffer剩余数据长度
                     * 1.正常则处理，缺少则等待数据再处理（接受其他的不完整数据？）
                     * 2.CRC16校验
                     * 3.调用Factory.Solve()
                    */
                    auto it = buffer.begin();
                    while (*it != RM_referee::StartOfFrame) {
                        it++;
                        if (it == buffer.end())
                            return 0;
                    }
                    if(bytes_transferred < sizeof(RM_referee::PacketHeader))
                        return 0;
                    std::memcpy(&header, &(*it), sizeof(RM_referee::PacketHeader));
                    //CRC8
                    // header.CRC8;
                    it+=sizeof(RM_referee::PacketHeader);
                    buffer.erase(buffer.begin(), it);
                    uint16_t cmd_id = static_cast<uint16_t>(*it << 8 | *(it+1));
                    //CRC16
                    //CRC16();
                    std::shared_ptr<uint8_t> parry(new uint8_t[header.DataLength]);//buf 只是临时设想！
                    MapSolve(cmd_id,&(*(it+2)),&(*parry));
                    /*
                    boost::asio::async_read(serialPort, boost::asio::buffer(buffer), boost::asio::transfer_exactly(header.DataLength),
                        [&, data = std::move(header)](const boost::system::error_code& ec, std::size_t bytes_transferred) mutable {
                            if (!ec) {
                                // 在这里处理完整的数据段
                                std::cout << "Received data: ";
                                for (auto byte : buffer) {
                                    std::cout << static_cast<int>(byte);
                                }
                                std::cout << std::endl;

                                // 继续下一次异步读取
                                // boost::asio::async_read(serialPort, boost::asio::buffer(buffer), boost::asio::transfer_exactly(sizeof(DataHeader)),
                                //     [&, header = DataHeader()](const boost::system::error_code& ec, std::size_t bytes_transferred) mutable {
                                //         // 处理下一次异步读取的完成事件
                                //     });
                            } else {
                                std::cerr << "Error: Incomplete data." << std::endl;
                            }
                        });
                    */
                } else {
                    std::cerr << "Error: Incomplete header." << std::endl;
                }
                return 0;
            }
            
        );

    };

        std::vector<uint8_t> buffer{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC1, 0x41, 0xA5, 0x1B, 0x00, 0xA6, 0x3A, 0x01, 0x02, 0x07, 0x01, 0x58, 0x02, 0x58, 0x02, 0xA0,
                                    0x00, 0xE0, 0x01, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x07, 0x21, 0xB0, 0xA5, 0x01, 0x00, 0xA7, 0x44, 0x06, 0x02, 0x10, 0x81, 0x42, 
                                    0xA5, 0x10, 0x00, 0xA8, 0xE4, 0x02, 0x02, 0x73, 0x57, 0x79, 0x00, 0xEA, 0x18, 0x2D, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2D, 0x9C, 0xA5, 0x10, 0x00, 0xA9, 0xBA,
                                    0x02, 0x02, 0x71, 0x57, 0x77, 0x00, 0x1B, 0xF7, 0x2A, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xDC, 0xA5, 0x10, 0x00, 0xAA, 0x58, 0x02, 0x02, 0x72, 0x57, 0x77, 0x00, 0x90, 0xF5, 
                                    0x2A, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB4, 0x71, 0xA5, 0x10, 0x00, 0xAB, 0x06, 0x02, 0x02, 0x70, 0x57, 0x79, 0x00, 0x2E, 0xBA, 0x2D, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 
                                    0x00, 0x00, 0x5D, 0x9E, 0xA5, 0x10, 0x00, 0xAC, 0x85, 0x02, 0x02, 0x72, 0x57, 0x77, 0x00, 0xB9, 0x4E, 0x2A, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x4D, 0xA5, 0x10, 0x00, 0xAD, 
                                    0xDB, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDA, 0xA5, 0xA5, 0x1B, 0x00, 0xAE, 0xF8, 0x01, 0x02, 0x07, 0x01, 0x58, 0x02, 0x58, 
                                    0x02, 0xA0, 0x00, 0xE0, 0x01, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x07, 0xD9, 0x6C, 0xA5, 0x10, 0x00, 0xAF, 0x67, 0x02, 0x02, 0x71, 0x57, 
                                    0x7A, 0x00, 0x54, 0x40, 0x2E, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xAB, 0xA5, 0x10, 0x00, 0xB0, 0xBB, 0x02, 0x02, 0x71, 0x57, 0x7A, 0x00, 0xB2, 0x84, 0x2E, 0x40, 0xC8, 0x00, 
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0xBF, 0xA5, 0x10, 0x00, 0xB1, 0xE5, 0x02, 0x02, 0x6B, 0x57, 0x78, 0x00, 0xA3, 0x74, 0x2C, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x31, 
                                    0xA5, 0x10, 0x00, 0xB2, 0x07, 0x02, 0x02, 0x73, 0x57, 0x77, 0x00, 0x0F, 0x81, 0x2A, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x45, 0xA5, 0x10, 0x00, 0xB3, 0x59, 0x02, 0x02, 0x72, 
                                    0x57, 0x79, 0x00, 0x58, 0x51, 0x2D, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3, 0x92, 0xA5, 0x10, 0x00, 0xB4, 0xDA, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAE, 0xBE, 0xA5, 0x1B, 0x00, 0xB5, 0x45, 0x01, 0x02, 0x07, 0x01, 0x58, 0x02, 0x58, 0x02, 0xA0, 0x00, 0xE0, 0x01, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x07, 0xCE, 0x74, 0xA5, 0x10, 0x00, 0xB6, 0x66, 0x02, 0x02, 0x73, 0x57, 0x78, 0x00, 0x8A, 0x61, 0x2B, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 
                                    0x00, 0x00, 0x71, 0x93, 0xA5, 0x10, 0x00, 0xB7, 0x38, 0x02, 0x02, 0x6F, 0x57, 0x79, 0x00, 0x7D, 0xCA, 0x2C, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0x15, 0xA5, 0x10, 0x00, 0xB8, 
                                    0x79, 0x02, 0x02, 0x6C, 0x57, 0x78, 0x00, 0x29, 0x4D, 0x2B, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5C, 0xED, 0xA5, 0x10, 0x00, 0xB9, 0x27, 0x02, 0x02, 0x6F, 0x57, 0x79, 0x00, 0x5F, 
                                    0xB3, 0x2C, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB4, 0xA5, 0x10, 0x00, 0xBA, 0xC5, 0x02, 0x02, 0x5A, 0x57, 0x78, 0x00, 0x03, 0x1E, 0x2C, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 
                                    0x00, 0x00, 0x00, 0xB0, 0xB3, 0xA5, 0x10, 0x00, 0xBB, 0x9B, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x13, 0xA5, 0x1B, 0x00, 
                                    0xBC, 0xD9, 0x01, 0x02, 0x07, 0x01, 0x58, 0x02, 0x58, 0x02, 0xA0, 0x00, 0xE0, 0x01, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x07, 0xFB, 0xC3, 
                                    0xA5, 0x10, 0x00, 0xBD, 0x46, 0x02, 0x02, 0x4E, 0x57, 0x79, 0x00, 0xE0, 0x73, 0x2C, 0x40, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9E, 0xC0, 0xA5, 0x10, 0x00, 0xBE, 0xA4, 0x02, 0x02, 0x4A, 0x57, 0x78, 0x00, 0x89, 0x76};
    void TypeMethodsTables::testprocess() {
        auto header = RM_referee::PacketHeader();
        auto it = buffer.begin();
            while (*it != RM_referee::StartOfFrame) {
                it++;
                if (it == buffer.end())
                    return;
            }
            // if(bytes_transferred < sizeof(RM_referee::PacketHeader))
            //     return ;
            std::memcpy(&header, &(*it), sizeof(RM_referee::PacketHeader));
            //CRC8
            // header.CRC8;
            it += sizeof(RM_referee::PacketHeader);
            /*****************************/
            buffer.erase(buffer.begin(), it);
            it = buffer.begin();
            /* 
            另一种写法不擦除buffer，继续处理
            ******************************/
            uint16_t cmd_id = static_cast<uint16_t>( ((*it)<<8) | (*(it+1)) );
            printf("0x%X\n",cmd_id);
            //CRC16
            //CRC16();
            std::shared_ptr<uint8_t> parry(new uint8_t[header.DataLength]);//buf 只是临时设想！
            MapSolve(cmd_id,&(*(it+2)),&(*parry));
    };

}